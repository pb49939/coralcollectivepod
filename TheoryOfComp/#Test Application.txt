# Theory of Comp, Lecture 1 
## Intro & Proof Techniques

Professor: **Laszlo Liptak** Office 368 MSC  
liptak@oakland.edu  
Attendance is taken  
Access to video recording of all lectures  
Notes will be scanned and uploaded after lectures  
Textbook: **Introduction to Languages and the Theory of Computation**, John C. Martin (Course is 4th edition, but previous editions are acceptable. 

#### Grades:  
  

  - HW Assignments **30%**  
	  - Help is acceptable, but cannot be identical to other students 
	  - One attempt is given to resubmit all hw assignments. After that, we can explain proof to prof directly. 
  - As we progress in the class, Liptak will provide us a list of terms we must be able to explain. We must make an appointment to explain any of these terms to the liptak. He will chose on the spot which. **30%**   
  - Final exam **40%**  

## Poof Techniques

#### Quantified Statements:   
*For all x, Px is true* (Universal Quantifier)  
ex: Every swan is white.  
ex: The square of an even number is even.  

*There exists an x much that P(x) is true* (Existential Quantifier)   

**For all x, P(x) is true for every P(x)**

| To show it is true | To show it is false |
| ------ | ------ |
| Pick a fixed, arbitrary value of x from the domain and show that p(x) is true using a general argument independent of x. | Find a counter example that is a specific value of x for which P(x) is false. |

**There exists an x such that P(x) is true.**

| To show it is true | To show it is false |
| ------ | ------ |
| Find a specific value of x for which P(x) is true. | Pick a fixed, arbitrary value of x from the domain and show that p(x) is false using a general argument independent of x. |


#### Proof Methods to show that P -> Q   
*P = Assumption, Q = Conclusion*

| P | Q | P -> Q | 
| --- | --- | --- | 
| T | T | T |
| T | F | F | 
| F | T | T | 
| F | F | T |    

ex. Promise: If it is Sunday,I will study for CSI 3430. 
We break our promise if: it is Sunday, and I am not studying for CIS 3430.  

**To show that P !-> Q**  
1. . **Direct Proof:** Assume that P is true, show that Q is also true. 
2. **Contropositive Proof:** Assume that Q is false, show that P is also false. 
3. **Contradiction (Indirect Proof):** Assume that P is true, and Q is false. Show a contradiction (an always false statement) that is a result of making this assumption. This is the preferred method as it lets us assume the most to allow us to get further in the proof. 
4. **Induction:** can be used if the statement depends on a subset of natural numbers.  
5. **Strong Induction:** 
   1. Base case, P(0)
   2. Show for all n in the domain, P(n+1) is also true  
   Direct proof: Assume P(0), P(1), .... P(n) are true. Show that P(n+1) are true 



| ex | 1^2 + 2^2 + ... + n^2 = [n(n+1)(2n+1)]/6 |   
| --- | --- | 
| P(0) is true (Base case, replace 0 with smaller element of domain) | n = 1, 1 = [1(1 + 1)(2 + 1)]/6 = 1 *CHECK* |
| Pick an arbitrary n >= 1. Assume that 1^2 + 2^2 + ... + n^2 = [n(n+1)(2n+1)]/6. **(Induction Hypothesis)** | Assume that the statement holds for something greater than the base case | 
| WTS:  
 1^2 + 2^2 + ... + n^2 + (n + 1)^2 = [(n+1)(n+2)(2(n+1)+1))]/6 |  Prove that each "rung on the ladder" is valid by proving n+1 is still true |
 
 
 ### Expectations 
 know all definitions, main theorems and their justification, and are able to perform the algorithm we discuss and solve problems similar to the ones on the HW. 
 
 
 ### Relations, Equivalence Relation  
 
 (: = the left and the right side have same value)  
 
 Definition: Given sets A,B, their cartesian Product in  
 A x B: = {(a, b): a in A, b in B} (Set of all ordered pairs that can be formed from A and B)
 
 A relation R, from A to B is an arbitrary subset of A x B. 
 
 If A = B, R is also called a relation on A. 
 
 ex 1. A = {42, 8, 6, 9} 
 
 R = {(8, 6), (8, 9), (6, 9), (42, 42), (6, 8)}
 
 ex 2. 
 A = {6, 8, 9, 42}
 
 < = {(6, 9), (6, 42), (8, 9), (8, 42), (9, 42)}
 
 we usually write: 6 < 8   
 usually we can write aRb to mean (a, b) is in R.  
 
 ex 3: = on A = {(6, 6), (8, 8), (9, 9), (42, 42)}  
 ex 4: congruence modulo 3 on A {(6, 6), (6, 9), (6, 42), (8, 8), (9, 6), (9, 9), (9, 42), (42, 6),(42, 9), (42, 42)}  
 **Definition:** Two integers are congruent modulo m if their difference is a multiple of m. 
 
 ### Potential Properties that relations on a set, A may have
 
 **Definition:** A relation R on A is equivalence relation iff R     
1. Reflexive (For all a in A, aRa) AND   
2. Symmetric (For all a,b in A aRb -> bRa) AND   
3. Transitive  (For all a,b,c in A: (aRb && bRc) -> aRc)

**Exercise:** Check which of the four examples we did in class are equivalence relations.  (3 and 4 are equivalence relations)  

Let R be an equivalence relation on A, and a in A. The equivalence class of a is the set [a]r := {b in A: aRb} ([a]r = set of elements in A that a is in relation with)

ex. Congruence Modulo 3 on N 

[0] = {0, 3, 6, 9, 12,...}  (3k)  
[1] = {1, 4, 7, 10, 13,...} (3k + 1)  
[2] = {2, 5, 8, 11, 14,...} (3k + 2)   


**Theorom:**  If a relation is an equivalence relation on A, then the set of equivalence classes with respect to the relation forms a *partition* of A, and the two elements of A are in relation with respect to the relation if and only if they belong to the same set of the partitions.   

A partition of set a is a set of subsets of A such that each element of A belongs to exactly one such subset. 

Claim: {[a]tilda : a in A} for a 

What to Show 
1. Each element belongs to exactly one equivalence class  
2. Two elements are in relation iff they belong to the same equivalence class.  

To show #1, we show that 
- Each element belongs to at least one class. Since a in relation with a (reflexive), a in [a] tilda.   
- No element belongs to two different equivalence classes. We show that if two equivalence classes share an element, then they are equal. 

**PROOF**  
Assume that c belongs to both [a] and [b] (equivalence class of a and equivalence class of b). 

*What to show*  
[a] = [b] is the same as [a] is a subset of [b] and [b] is a subset of [a].   
**Ugly Proof**  
To show [a] is a subset of [b] we need to show that for any d in [a], we have a d in [b]. To Show, we assume d in [b] and show d is in [b]. Assumptions: c in [a], c in [b], d in [a]. By definition, A is in relation c, b is in relation with c, and a is in relation with d. What to show: d belongs to [b] is equivalent to b being in relation with d. We know that b is in relation with c, c is in relation with a, and a is in relation with d. B is in relation with a, and a is in relation with d. Conclusion, b is in relation with d.   

**Actual Proof**
Assume that c belongs to [a], [b].   
Pick any element d of [a].   
Since c belongs to [b], b is in relation with c.  
Since c also belongs to [a], a is in relation with c.  
Since the relation is symmetric, this implies that c is in relation with a.  
Since b is in relation with c and c is in relation with a, by transitivity of the relation ->   
We get that b is in relation with a. 
Since d belongs to [a], we have that a is in relation to d.  
Since b is in relation with a and a is in relation with d, by transitivity of the relation, we get that b is in relation with d.   

To show that [b] is a subset of [a], use the same argument with the roles of a, b reversed (by symmetry).  

So the set of equivalence classes form a partition of A.   

Two elements a, b are in the same equivalence class iff a is in relation to b.   

Assume that a,b belong to [c], then [a], [c] share an element (a), so [a] = [c]. Similarly, [b], [c] share an element (b) so [b] = [c]. Due to transitivity, [a] = [b] = [c], and contain a, b, c. 

Assume that a is in relation with b. Assume that b belongs to [a] then [b] and [a] share en element (b), so [b] = [a]. 




## Strings (Languages)  
**Def:** An Alphabet is a finite, non-empty set of symbols usually denoted by Sigma, Gamma.  

**String:** finite sequence of symbols from the alphabet written one after another. Usually denoted by v,w,x,y,z.  

ex. Sigma = {a, b, c}  

strings over Sigma: abc, a, emptyString, abcc, bab, bacbc  

Length of a string is just the number of symbols in the string (with multiplicity). We use "| |" to denote length.  
ex. |abc| = 3, |emptyString| = 0, |baba| = 4  

The set of all finite strings over the alphabet Sigma, is denoted by Simga Star.   

**Operations that we can do on strings**:    
*Concatenation:* Write the second string after the first string to get a new string. Write * for the concat operation (usually omitted).   
ex. w = cab, z = abc   
w*z = cababc  
z*w = abccab  (*concat is usually not combinative*)    
w*w = cabcab 

### Logic Symbols 
From some website: 
![Logic Symbols](https://patrickbaldwin.design/theoryofcomp/images/logic-symbols.png "Logic Symbols") 


### Suggested Exercises: Ch 1: 4-6, 8, 11, 12, 14, 19, 20, 22, 26, 29, 31-37, 42, 44. 

- **1.4** A tautology is two ways to say the same thing, even though they might look different. 
Â :not 




# Finite Automoton  

FA = (Q, Sigma, sigma0, A, delta) 

- Q: finite set of states
- Sigma: finite, non empty alphabet 
- sigma0 in Q: starting state 
- A is a subset of Q: set of accepting states
- delta: Q x Sigma -> Q is the transition function 

**Extend delta to delta* : Q x Sigma* -> Q recursively**  
1. delta*(Q, Lambda *empty string*) = q for every q in Q  
2. delta*(q, ya) := delta(delta*(q, y), a)  

Language accepted by M is  
	**L(M) := {x in Sigma*: delta*(q0, x) is in A)}**  
	
**Example from last time:** construct FA that accepts those binary strings which represent numbers divisible by 3 in base 2.  Exclude Lambda, beginning 0s ,  

States: q0, 0, 1, 2  *0 = remainder of 0, 1 = remainder 1, 2 = remainder 2*   

- Q: {q0, 0, 1, 2}
- Sigma: {0, 1}
- q0: q0 
- A = {0}  

## **Example 2** 

*Construct a FA that accepts those strings in {a, b}* that end w "ba"*

**Idea:** keep track of up to the last two symbols of the input string and move accordingly. We will accept if we reach a state corresponding to "ba".  

- States: Lambda *empty string*, a, b, aa, ab, ba, bb


| ending | next | state |
| --- | --- | --- |
| aa | a | aa |
| aa | b | ab |
| ab | a | ba |
| ab | b | bb |
| aa | a | aa |
| aa | b | ab |
| ab | a | ba |
| ab | b | bb |

## Example 3  
*Find a FA that accepts exactly those strings over {a, b} that end with abbaba. 

If we use same idea from example 2, we have all states possible for this finite automoton = 2^6 + 2^5 + 2^4 + 2^3 + 2^2 + 2^1 = 127 states. This is too many states to draw out. 

Instead, let's use only the potential prefixes of our target string and keep track of the longest suffix of the input read so far that is a prefix of the target string.  

States needed: Lambda *empty string*, a, ab, abb, abba, abbab, abbaba   

**Knuth - Morris - Pratt string search algorithm**    
- Lambda x b -> Lambda   *since no accepting string can start with "b", we have to start over at lambda*  
- a x a ->  a *starting from lambda, if we read a, then we move to a* 
- ab x a -> a *starting from lambda, move according to ba bc in the string, aba, the last "a" can stilll be useful to get to an accepting state*
- abb x b -> lambda *starting from lambda, move according to bbb, which makes the next state return to lambda* 
- abba x a -> a 
- abbab x b -> abb *from lambda, move according to bbabb
- abbaba x a -> a 
- abbaba x b -> ab

*Lesson:* While we are constructing the machine, we can use what currently exists to build the rest of the machine* 



**Definition of delta (star)**
If we are in some state and we read nothing, stay put (state does not change)   

If we are in state y and read symbol a, we move according to y and then make one more move according to the last symbol, a.  

For every q in Q, y in Sigma*, a in Sigma  

**Theorom:** If certain languages can be accepted by a finite automoton, than other such languages can be accepted by a finite automoton.  

If L1 and L2 are languages accepted by FAs M1 and M2 respectively, then there are FA that accept L1 Union L2, L1 Intersection L2, L1 minus L2, and L1 compliment (= Sigma * - L1). 

**Proof**  
Assume that M1 = (Q1, Sigma, q1, A1 delta1) and M2 = (Q2, Sigma, q2, A2 delta2). The language accepted by M1 = L1 and the language accepted by M2 is L2.  
 
*L(M1) = L1 && L(M2) = L2*  

*Idea is to keep track of the moves of both machines as we read the input. Use pairs of states to remember the state of each machine.*  

Define M=(Q, Sigma, q0, A, delta) where  
Q := Q1 x Q2 (cartesian product of the pair of the states from each machine)  
q0 := (q1, q2)  

delta((p1, p2), a) := (delta1(p1, a), delta(p2, a))   

For L1 Union L2, set A := {(p1, p2) in Q1 x Q2: p1 in A1 or p2 in A2}  **OR** = (A1 x Q2) Union (Q1 x A2) 

*Accept if the first machine is in an accepting state or if the second machine is in an accepting state* 

For L1 Intersection L2, set A := {(p1, p2) in Q1 x Q2: p1 in A1, p2 in A2} = A1 x A2 

For L1 - L2 set A := {(p1, p2) in Q1 x Q2: p1 in A1, p2 not in A2} = A1 x (Q2 - A2)  

For L1 ' (Compliment of L1) use only M1 and set the set of accepting states to be Q1 - A1 *All of the states in Q1 that are not in the accepting states, A1* 

**Suggested Exercises:** {CH1: 52, 55, 60, 61, 68}, {CH2: 1, 4-9, 21, 22, 24, 27, 29, 33, 34, 40, 44, 54}  

**Fininate Automoton** a FA is a five tuple M such that M = (Q, Sigma, q0, A, delta) 

- Q = finite set of states 
- Sigma = finite, non-empty alphabet 
- q0 = starting state 
- A = set of accepting states that is a subset of Q
- delta = the transition function (*the moves*) Q x Sigma -> Q 

Fix language L over some Alphabet Sigma (L is a subset of Sigma *)

**Definition** Two strings x,y in Sigma* are distinguishable with respect to L (Also called L-distinguishable) if there exists a string z in Sigma * such that *exactly* one of the two strings xz, yz is in L.  

We say that such z *distinguishes x from y*  

**Example 1**  
L = pal (the set of palendrones) over {a,b} 

x = aba  
y = bab  

*idea is we need to find a string such that if we appended it to both x and y, only one of x and y would be a palindrome* 

chose z = ab -> x = abaab (NOT PAL), y = babab (IS PAL)

**Example 2** 
x = aba,  *Is in PAL* 
y = baa   *Is not in PAL*

chose z = lambda (the empty string) bc x is in PAL already, and y is not, so by appending the the empty string, they x and y are PAL-distinguishable 

**Example 3** 

x = baa, 
y = abb 

we will choose z = a 

xz = baaa (Not in PAL) and xy = abba (In PAL). This means that x and y are PAL distinguishable. 

**Example 4** 

x = baa, 
y = baaa 

chose z = b. xz = baab (IN PAL), xy = baaab (IN PAL). So now we know that z does not distinguish x from y with respect to PAL. 

try again, lets chose z = babaab. xz = baababaab (IN PAL), xy = baaababaab (NOT IN PAL). So then we know that x and y are PAL distinguishable. 

**Example 5** 

L = {a, b}* ba  *This is the language of strings a,b that end in ba*

x = aba 
y = abb 

chose z = lambda (empty string) -> xz = aba (Not IN L), yz = abb (IN L). So we know that x and y are L distinshiushable. 


now take 

x = aab, 
y = bbb 

If we chose z to be a, then both strings would be in the language. Essentially, both of these will be in L, or neither of them will be in L. We now need to show that no z will distinguish x from y. 

**Proof by Cases** 

case 1: z = Lambda (empty string) -> neither string is in L   
case 2: z = a -> both strings are in L   
case 3: z = b -> neither strings are in L  
case 4: |z| >= 2 -> the last two symbols of z will be the same.   This means that if the length of z is greater than or equal to 2, no matter what we chose z to be, either both xz and yz will be in L or neither xz or yz will be in L. 

Since in none of the cases will z distinguish x from y with respect to language L, x and y are **NOT** L distinguishable. Or in other words, *x and y are L indistinguishable* 

**Lemma 1**  
Given a finite autamoton, M=(Q, Sigma, q0, A, delta), for all strings x,y and for every state q in Q, we have that 

**1** = delta*(q, xy) is the state that the machine ends up in if it starts at q and reads xy. 

**2** = delta(*(delta*(q, x), y) is the state that the machine ends up in if it first starts at state q and then reads x and then reads state y following. 

1 and 2 are equal. 


**This is going to be proved by induction** 

But now we have a new Lemma 

**Lemma 2** If M is a FA accepting language L and x, y are strings in Sigma* such that if delta*(q0, x) = delta*(q0, y), then x and y are L indistinguishable. 


**Proof** 

*Assumption a* Assume that d*(q0, x) = d*(q0, y). *We want to show that for every Z in Sigma star, xz, yz are both in L, or they both are not in L.*

Pick any z in Sigma*. 

d*(q0, xz)         = (*By previous Lemma*)   
= d*(d*(q0, x), z) = (*By our assumption a*)   
= d*(d*(q0, y), z) = (*by previous Lemma*)    
= d*(q0, yz)

So depending on whether d*(q0, xz) is in A or not, either both strings xz, yz will be in L neither will be in A. 


**Take contrapositive of Lemma 2** 

If x, y are L distinguishable, then the states that we end up in must be different. 

d*(q0, x) != d*(q0, y)

**Corollary 1** 

If M is a FA accepting L and x1, x2, ... , xn are pairwise L-distinguishable strings, then M must have at least n different states. 

**Proof** 
d*(q0, x1), d*(q0, x2), .... , d*(q0, xn) must be all different bc any two of the strings x1, x2, ..., xn are L-indistinguishable. So |Q| >= n. 

**Corollary 2** 

If for a language L, there are infinitely many pairwise, L distinguishable strings, then no finite automaton can accept L. 

**Proof** 
By contradiction, assume M is a FA accepting L. Let n = |Q|. By assumption, we can find n + 1 pairwise L distinguishable strings. So by Corollary 2, M must have at least n + 1 strings. But this is a contradiction, bc it only has n. 

**Theorem** 

PAL = {x in {a, b}* : a is a palindrome} (x^R = x). 

PAL cannot be accepted by a finite automaton. 

**Proof** 

We show that any two different strings xy in {a, b}* are PAL distinguishable. So by Corollary 2, no FA can accept PAL. 

**In order to accept PAL, you must remember the entire string that has been processed so far by the nature of deciding if a string is in PAL. This requires infinite states and storage. Thus not possible* 

Given two fixed strings x, y in {a, b}* where x != y. 


*Idea is to first take the reverse of the first string and then add something to the middle of the first string after the first part and before the part that we just added that would make adding that string to each the first and second string, only one of them result in a PAL*. 

Without loss of generality (WLOG), we may assume that x is not longer than y. (If x *is* longer, then just swap them).  

- Case 1: |x| = |y| -> chose z = the reverse of x. Then xz = xx^r which is in PAL. But yz = yx^r bc x != y. 
- Case 2: |x| < |y| -> chose z = cx^r such that c is in {a, b}* and xc is not a prefix of y. *(chose c different from the corresponding symbol in y y=****** + different form c)* Then xz = xcx^r which is not in PAL bc xc is not a prefix of y. 

**Exercise** 
If a finite automaton could have infinitely many states, show that it could accept any language. 

**Claim** 
Ln := {x in {a, b}* such that |x| >= n and the nth symbol from the right in x is 'a'}   

Given the above language, any FA accepting Ln must have at least 2^n states. We must remember n strings from the end at all times. 


**Proof** We must show that any two different strings of length n are Ln distinguishable. 

Pick x, y such that they both have length n where x != y. 

Since x != y, they must differ in some symbol in the kth position for some k between 1 and n. 

Say WLOG x has a in the kth position and y have b in the kth position. 

We will choose z to be any string such that in "xz, yz" this will be the nth position from the right. This will be any string of length (k - 1). 

**Pumping Lemma** 

idea -> we are given a FA M with n states, accepting language L. Consider a string, x in Sigma star such that |x| >= n.   

x = x1x2x3...xm where m>=n   

As M reads x, it goes through some states. During the computation of the FA, M goes through n + 1 states. But it only has n states. So at least one state must have been repeated. In math writing, this means that 

d*(q0, y1y2y3y4y5) = qn  **AND**
d*(q0, y1y5) = qn **AND**
d*(q0, y1y2y2y2y2y2y2y5) = qn

If qn is an accepting state, then ew know that we have multiple strings that will be in the accepting state. 

**Theorem and actual Pumping Lemma** 
 Let L be a language accepted by a FA M with n states. If x is in L such that t |x| >= n, then we can write x in the form 
1. x = uvw  *for some strings u, v, w*
2. |uv| <= n, |v| >= 1 
3. (u)(v^k)(w) is in the language L. (For k=0,1,2,3.....) *You can PUMP v as many times as you want and the resulting string will still be in the language L* 


**Proof** 
As M reads x, it will read its symbols. Since |x| >= n, during this it will go through at least n + 1 states. So at least one state q must repeat. (Let q be the first repeated state). Let u be the portion of x until M gets to q and let v be the portion of x until M gets to q the second time, and let w be the rest of x: 

**q0** ---u---> **q** -----w---> **A** (Accepting State).
There is also so v that links **q** back to itself. 

Since q in the first repeated state, |uv| <= n and clearly |v| >= 1 and uv^kw is in L for every k in real numbers. 

PL (Pumping Lemma) can be used to show that certain languages can't be accepted by any finite automaton. 


















  


  

















 























 
 
 
 
 
 
 
 
  
 
 
  







 

 
 





